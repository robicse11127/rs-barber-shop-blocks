import { markToTrack, getUntracked } from 'proxy-compare';

const isObject = (x) => typeof x === "object" && x !== null;
const PROXY_STATE = Symbol();
const refSet = /* @__PURE__ */ new WeakSet();
const buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, receiver, version, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(receiver);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(receiver, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key, receiver);
    if (refSet.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (value == null ? void 0 : value[PROXY_STATE]) {
      snap[key] = snapshot(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1], proxyFunction2 = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  const propListeners = /* @__PURE__ */ new Map();
  const getPropListener = (prop) => {
    let propListener = propListeners.get(prop);
    if (!propListener) {
      propListener = (op, nextVersion) => {
        const newOp = [...op];
        newOp[1] = [prop, ...newOp[1]];
        notifyUpdate(newOp, nextVersion);
      };
      propListeners.set(prop, propListener);
    }
    return propListener;
  };
  const popPropListener = (prop) => {
    const propListener = propListeners.get(prop);
    propListeners.delete(prop);
    return propListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    get(target, prop, receiver) {
      if (prop === PROXY_STATE) {
        const state = [
          target,
          receiver,
          version,
          createSnapshot,
          listeners
        ];
        return state;
      }
      return Reflect.get(target, prop, receiver);
    },
    deleteProperty(target, prop) {
      var _a;
      const prevValue = Reflect.get(target, prop);
      const childListeners = (_a = prevValue == null ? void 0 : prevValue[PROXY_STATE]) == null ? void 0 : _a[4];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a, _b;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && objectIs(prevValue, value)) {
        return true;
      }
      const childListeners = (_a = prevValue == null ? void 0 : prevValue[PROXY_STATE]) == null ? void 0 : _a[4];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      if (isObject(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_b = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _b.set) ; else if (value instanceof Promise) {
        value.then((v) => {
          value.status = "fulfilled";
          value.value = v;
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          value.status = "rejected";
          value.reason = e;
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!(value == null ? void 0 : value[PROXY_STATE]) && canProxy(value)) {
          nextValue = proxy(value);
        }
        if (nextValue == null ? void 0 : nextValue[PROXY_STATE]) {
          nextValue[PROXY_STATE][4].add(
            getPropListener(prop)
          );
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key
    );
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  proxyFunction2,
  PROXY_STATE,
  refSet,
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
const [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function getVersion(proxyObject) {
  const state = proxyObject == null ? void 0 : proxyObject[PROXY_STATE];
  return state == null ? void 0 : state[2];
}
function subscribe(proxyObject, callback, notifyInSync) {
  if ((import.meta.env && import.meta.env.MODE) !== "production" && !(proxyObject == null ? void 0 : proxyObject[PROXY_STATE])) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const listeners = proxyObject[PROXY_STATE][4];
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (listeners.has(listener)) {
          callback(ops.splice(0));
        }
      });
    }
  };
  listeners.add(listener);
  return () => listeners.delete(listener);
}
function snapshot(proxyObject, handlePromise) {
  if ((import.meta.env && import.meta.env.MODE) !== "production" && !(proxyObject == null ? void 0 : proxyObject[PROXY_STATE])) {
    console.warn("Please use proxy object");
  }
  const [target, receiver, version, createSnapshot] = proxyObject[PROXY_STATE];
  return createSnapshot(target, receiver, version, handlePromise);
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
const unstable_buildProxyFunction = buildProxyFunction;

export { getVersion, proxy, ref, snapshot, subscribe, unstable_buildProxyFunction };
